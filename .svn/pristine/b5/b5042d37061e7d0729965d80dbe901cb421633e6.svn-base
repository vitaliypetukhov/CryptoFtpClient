#pragma once
#define _CRT_SECURE_NO_DEPRECATE
#define _WTL_NO_CSTRING

#define ERROR_FTP_COMMAND_LIST WM_USER + 100
#define ERROR_LOCAL_CREATE_FILE WM_USER + 200
#define ERROR_LOCAL_CREATE_DIRECTORY WM_USER + 201

#include "Client.h"

HINTERNET hInternet = 0;
HINTERNET hIConnect = 0;
// Установка хендлов элементов
void FtpClient::SetControls(HWND &_hEditAdress, HWND &_hEditUserName, HWND &_hEditUserPassword, 
		HWND &_hButtonConnect, HWND &_hButtonDownload, HWND &_hButtonUpload,
		HWND &_hLocalListView, HWND &_hFtpListView,
		HWND &_hComboBox, HWND &_hStatusBar)
{
	hEditAdress = _hEditAdress;
	hEditUserName = _hEditUserName;
	hEditUserPassword = _hEditUserPassword;
	hButtonConnect = _hButtonConnect;
	hButtonDownload = _hButtonDownload;
	hButtonUpload = _hButtonUpload;
	hLocalListView = _hLocalListView;
	hFtpListView = _hFtpListView;
	hComboBox = _hComboBox;
	hStatusBar = _hStatusBar;
}
// Сортировка списка файлов
void FtpClient::FilesSort(vector<WIN32_FIND_DATA> &vec)
{
	// Векторы папок и файлов
	vector<WIN32_FIND_DATA> folders, files;
	// Временная переменная
	WIN32_FIND_DATA temp;
	// Количество элементов в папке
	long len = vec.size();
	// Собираем векторы папок и файлов
	for(long i = 0; i < len; i++)
		if(vec.at(i).dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			folders.push_back(vec.at(i));
		else
			files.push_back(vec.at(i));
	// Получить количество папок
	int folderCount = folders.size();
	// Получить количество файлов
	int filesCount = files.size();
	// Поиск в списке файлов папки перехода на верхний уровень
	long dotsFound = -1;
	for(long i = 0; i < folderCount && dotsFound == -1; i++)
		if(strcmp(vec.at(i).cFileName, "..") == 0)
			dotsFound = i;
	// Если папка найдена
	if(dotsFound != -1)
	{
		// Ставим папку перехода на верзний уровень в первую позицию списка папок
		memset(&temp, 0, sizeof(WIN32_FIND_DATA));
		temp = folders.at(0);
		folders.at(0) = folders.at(dotsFound);
		folders.at(dotsFound) = temp;
	}
	// Сортируем папки по алфавиту
	for(long i = (dotsFound == -1) ? 0 : 1; i < folderCount; i++)
		for(long j = i + 1; j < folderCount; j++)
			if(folders.at(i).cFileName > folders.at(j).cFileName)
			{
				memset(&temp, 0, sizeof(WIN32_FIND_DATA));
				temp = folders.at(i);
				folders.at(i) = folders.at(j);
				folders.at(j) = temp;
			}
	// Сортировка файлов
	for(long i = 0; i < filesCount ; i++)
		for(long j = i + 1; j < filesCount; j++)
			if(files.at(i).cFileName > files.at(j).cFileName)
			{
				memset(&temp, 0, sizeof(WIN32_FIND_DATA));
				temp = files.at(i);
				files.at(i) = files.at(j);
				files.at(j) = temp;
			}
	// Очищаем вектор элементов
	vec.clear();
	// Собираем новый вектор
	for(size_t i = 0; i < folders.size(); i++)
		vec.push_back(folders.at(i));
	for(size_t i = 0; i < files.size(); i++)
		vec.push_back(files.at(i));
}
// Формирование строки ошибки
void FtpClient::CheckLastError(DWORD code, char * szErrorBuff)
{
	switch(code)
	{
	case ERROR_INTERNET_LOGIN_FAILURE:
		sprintf(szErrorBuff, "Не удалось выполнить запрос на подключение и вход на FTP-сервер.");
		break;
	case ERROR_INTERNET_INCORRECT_PASSWORD:
		sprintf(szErrorBuff, "Не удалось выполнить запрос на подключение и вход на FTP-сервер, поскольку указан неверный пароль.");
		break;
	case ERROR_INTERNET_CANNOT_CONNECT:
		sprintf(szErrorBuff, "Не удалось подключиться к серверу.");
		break;
	case ERROR_INTERNET_CONNECTION_ABORTED:
		sprintf(szErrorBuff, "Соединение с сервером было разорвано.");
		break;
	case ERROR_FTP_DROPPED:
		sprintf(szErrorBuff, "FTP-операция не завершена из-за прекращения сеанса.");
		break;
	case ERROR_INTERNET_TIMEOUT:
		sprintf(szErrorBuff, "Запрос просрочен.");
		break;
	case ERROR_INTERNET_NAME_NOT_RESOLVED:
		sprintf(szErrorBuff, "Не удалось разрешить имя сервера.");
		break;
	case ERROR_FTP_COMMAND_LIST:
		sprintf(szErrorBuff, "Ошибка получения списка файлов");
		break;
	case ERROR_LOCAL_CREATE_FILE:
		sprintf(szErrorBuff, "Ошибка создания локального файла");
		break;
	case ERROR_LOCAL_CREATE_DIRECTORY:
		sprintf(szErrorBuff, "Ошибка создания локального каталога");
		break;
	case ERROR_INTERNET_EXTENDED_ERROR:
		{
			sprintf(szErrorBuff, "Сервер возвратил расширенную ошибку. Как правило, это строка или буфер, содержащие сообщение об ошибке. Вызовите функцию InternetGetLastResponseInfo для получения текста ошибки.");
			DWORD dwInetError;
			DWORD dwExtLength = 1000;
			TCHAR *szExtErrMsg = NULL;
			TCHAR errmsg[1000];
			szExtErrMsg = errmsg;
			if(InternetGetLastResponseInfo( &dwInetError, szExtErrMsg, &dwExtLength ))
			{
				sprintf(szErrorBuff, "%s\n %d", szExtErrMsg, code);
			}
		}
		break;
	case ERROR_FTP_TRANSFER_IN_PROGRESS:
		sprintf(szErrorBuff, "Запрошенную операцию невозможно выполнить для дескриптора FTP-сеанса, так как операция уже выполняется.");
		break;
	
		/*sprintf(szErrorBuff, "Ошибочный хендл.");
		break;*/
	default:
		sprintf(szErrorBuff, "Неизвестная ошибка. Код ошибки: %d", code);
		break;
	}

	
}
// Функция коннекта
DWORD FtpClient::Connect(Settings &_settings)
{
	settings = _settings;
	// Открываем интернет соединение
	hInternet = InternetOpen("Test FTP Client", INTERNET_OPEN_TYPE_PRECONFIG, 0, 0, INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE);
	// Если не открылось - выход
	if(!hInternet)
		return GetLastError();
	// Создаем FTP подключение по указанному пути, на фтп порт 21, с заданными логином и паролем
	if(strcmp(settings.Login.c_str(), "anonymous") == 0 && settings.Password.size() == 0)
		strcpy((char*)settings.Password.c_str(), "anonymous@mail.com");
	hIConnect = InternetConnect(hInternet, settings.Adress.c_str(), settings.connectionPort, 
		settings.Login.c_str(), settings.Password.c_str(), INTERNET_SERVICE_FTP, INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE, 0);
	// Проверка открытия соединения
	if(!hIConnect)
	{
		InternetCloseHandle(hInternet);
		return GetLastError();
	}
	return 0;
}
// Функция закрытия соединения
void FtpClient::Disconnect()
{
	// Закрываем хедеры
	InternetCloseHandle(hIConnect);
	InternetCloseHandle(hInternet);
	hIConnect = 0;
	hInternet = 0;
	// Включаем поле ввода имени сервера
	SendMessage(hEditAdress, EM_SETREADONLY, FALSE, 0);
	// Включаем поле ввода логина
	SendMessage(hEditUserName, EM_SETREADONLY, FALSE, 0);
	// Включаем поле ввода пароля
	SendMessage(hEditUserPassword, EM_SETREADONLY, FALSE, 0);
	// Очищаем список фтп файлов
	ListView_DeleteAllItems(hFtpListView);
	// Выключаем левый список
	EnableWindow(hFtpListView, FALSE);
	EnableWindow(hButtonDownload, FALSE);
	EnableWindow(hButtonUpload, FALSE);
	// Изменяем название кнопки
	SendMessage(hButtonConnect, WM_SETTEXT, sizeof("Connect"), LPARAM("Connect"));	
	SendMessage(hStatusBar, (UINT) SB_SETTEXT, (WPARAM)(INT) 0 | 0, (LPARAM) 0);
}
// Смена локального каталога
DWORD FtpClient::LocalChangeDir(const char * szDirName)
{
	// Текущий путь
	CHAR szPath[MAX_PATH] = {0};
	// Путь перехода
	CHAR szFPath[MAX_PATH] = {0};
	// Получаем данные о текущем пути сохраненном в статус баре
	SendMessage((HWND) hStatusBar, (UINT) SB_GETTEXT, (WPARAM)(INT) 1 | 0, (LPARAM) szPath);
	// Добавляем в путь перехода
	_tcscat(szFPath, szPath);
	// Добавляем папку в которую переходим
	_tcscat(szFPath, szDirName);
	// Если название папки не ".." - добавим завершающий слеш
	if(strcmp(szDirName, "..") != 0)
		_tcscat(szFPath, "\\");
	// Меняем текущуее местоположение
	SetCurrentDirectory(szFPath);
	// Очищаем путь перехода
	memset(szPath, 0, sizeof(char) * MAX_PATH);
	// Получаем текущее расположение
	GetCurrentDirectory(MAX_PATH, szPath);
	// Если не добрались до корня диска 
	if(szPath[strlen(szPath) - 1] != '\\')
		// Добавляем к пути завершающий слеш
		_tcscat(szPath, "\\");
	// Выводим новый путь в статус бар
	SendMessage(hStatusBar, SB_SETTEXT, (WPARAM)(INT) 1 | 0, (LPARAM) szPath);
	// Возвращаем результат работы
	return GetLastError();
}
// Показ содержимого локального каталога
DWORD FtpClient::LocalShowDir(vector<WIN32_FIND_DATA> &localList)
{
	TCHAR szPath[MAX_PATH] = {0};
	TCHAR szFPath[MAX_PATH] = {0};
	// Количество элементов текущей папки
	int itemsCount = 0;
	// Создаем структуру поиска
	HANDLE hFind = 0;
	// Список иконок
	HIMAGELIST imageList = 0;
	// Структура для поиска файлов
	WIN32_FIND_DATA *w32FindData = new WIN32_FIND_DATA;
	// Cтруктура для поиска иконки связанной с типом файла
	SHFILEINFO sfi;
	// Структура элемент списка
	LVITEM lvItem;
	// Маркер завершения операций поиска
	BOOL fContinue = TRUE;
	// Имя файла
	string str = "";
	// Очищаем сисок файлов
	ListView_DeleteAllItems(hLocalListView);
	ListView_SetExtendedListViewStyleEx(hLocalListView, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);
	// Очищаем список структур файлов
	localList.clear();	
	// Обнуляем поля структуры
	memset(w32FindData, 0, sizeof(WIN32_FIND_DATA));
	// Формируем полную строку нового пути перехода
	SendMessage((HWND) hStatusBar, (UINT) SB_GETTEXT, (WPARAM)(INT) 1 | 0, (LPARAM) szPath);
	// Добавляем путь директории
	_tcscat(szFPath, szPath);
	// Добавляем маску  поиска
	_tcscat(szFPath, "*.*");	
	// Ищем первый файл в директории
	hFind = FindFirstFile(szFPath, w32FindData);
	// Создаем список изображений (храним иконки к файлам)
	imageList = ImageList_Create(
		GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_MASK | ILC_COLOR32, 1, 1);
	// Цикл поиска файлов в текущей директории фтп сервера
	do 
	{
		if(strcmp(w32FindData->cFileName, ".") != 0 && (w32FindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) == 0)
		{		
			// Добавляем инфо структуру файла в список структур
			localList.push_back(*w32FindData);
			// Количество элементов увеличилось
			itemsCount++;
		}
		// Переходим к следующему файлу
		memset(w32FindData, 0, sizeof(WIN32_FIND_DATA));		
		// Пока есть файлы -ищем дальше
		fContinue = FindNextFile(hFind, w32FindData);
	// Пока есть файлы
	} while(fContinue);
	// Сортировка
	FilesSort(localList);
	// Построение списка
	for(size_t i = 0; i < localList.size(); i++)
	{
		memset(&lvItem, 0, sizeof(LVITEM));
		// Заполняем поля информацией
		lvItem.mask = LVIF_IMAGE|LVIF_TEXT;
		lvItem.state = 0;
		lvItem.stateMask = 0 ;
		lvItem.iItem = i;
		lvItem.iImage = i;
		lvItem.iSubItem = 0;
		lvItem.pszText = localList.at(i).cFileName;
		lvItem.cchTextMax = sizeof(localList.at(i).cFileName);
		// Добавляем в список
		ListView_InsertItem(hLocalListView, &lvItem);
		if(strcmp(localList.at(i).cFileName, "..") != 0)
		{
			lvItem.iSubItem = 1;
			SYSTEMTIME sysTime;
			FileTimeToSystemTime(&localList.at(i).ftCreationTime, &sysTime);
			stringstream strStream;
			strStream << sysTime.wDay << "." << sysTime.wMonth << "." << sysTime.wYear;
			string temp = strStream.str();
			lvItem.pszText = (LPSTR)temp.c_str();
			lvItem.cchTextMax = temp.size();
			ListView_SetItem(hLocalListView, &lvItem);

			strStream.str().resize(0);
			strStream.str().clear();
			strStream.str("");
				
			lvItem.iSubItem = 2;
			LONGLONG size = 0;
			size =  localList.at(i).nFileSizeHigh + localList.at(i).nFileSizeLow;
			if (size == 0)
				strStream << "";
			else if (size < 1024)
				strStream << size << " B";
			else if (size< 1024 * 1024)
				strStream << 1.0 * size / 1024 << " Kb";
			else
				strStream << 1.0 * size / 1024 / 1024 << " Mb";
			temp = strStream.str();
			lvItem.pszText = (LPSTR)temp.c_str();
			lvItem.cchTextMax = temp.size();
			ListView_SetItem(hLocalListView, &lvItem);
		}			
		// Обнуляем поля
		ZeroMemory(&sfi, sizeof(SHFILEINFO));
		// Получаем информацию о переданном элементе
		SHGetFileInfo(localList.at(i).cFileName, localList.at(i).dwFileAttributes, &sfi, sizeof(SHFILEINFO), 
			SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES | SHGFI_EXETYPE);		
		// Добавляем иконку в список иконок
		ImageList_AddIcon(imageList, sfi.hIcon);
	}
	// Сбор данных о элементах директории закончен
	// Добавляем иконки к списку элементов
	ListView_SetImageList(hLocalListView, imageList, LVSIL_SMALL);
	// Освобождаем выдыленную память
	delete w32FindData;
	// Закрываем перечеслитель файлов
	FindClose(hFind);
	// Все прошло без ошибок
	return 0;
}
// Перейти в новый каталог
DWORD FtpClient::FtpChangeDir(const char * szDirName)
{
	// Проверка открытия соединения
	if(!hIConnect)
		// Если соединение закрыто - вернем код ошибки
		return GetLastError();
	// Новый путь перехода
	TCHAR szNewDirName[MAX_PATH] = {0};
	// Старый путь
	TCHAR szOldDirName[MAX_PATH] = {0};
	// Получаем данные о текущем пути сохраненном в статус баре
	SendMessage((HWND) hStatusBar, (UINT) SB_GETTEXT, (WPARAM)(INT) 0 | 0, (LPARAM) szOldDirName);
	// Формируем новый путь добавляя указанную папку
	_tcscat(szNewDirName, szOldDirName);
	// Добавляем разделитель если это необходимо
	if(strcmp(szOldDirName, "/") != 0)
		_tcscat(szNewDirName, "/");
	// Формируем полную строку нового пути перехода
	_tcscat(szNewDirName, szDirName);
	// Преобразовываем к UTF-8 формату
	string str = szNewDirName;
	// Меняем текущуее местоположение
	FtpSetCurrentDirectory(hIConnect, str.c_str());
	// Возвращаем результат работы
	return GetLastError();
}
// Сбор и вывод информации о содержимом текущего каталога
DWORD FtpClient::FtpShowDir(vector<WIN32_FIND_DATA> &ftpList)
{
	// Количество элементов текущей папки
	int itemsCount = 0;
	// Создаем структуру поиска
	HINTERNET hInternetFind = 0;
	// Список иконок
	HIMAGELIST imageList = 0;
	// Структура для поиска файлов
	WIN32_FIND_DATA *w32FindData = new WIN32_FIND_DATA;
	// Cтруктура для поиска иконки связанной с типом файла
	SHFILEINFO sfi;
	// Структура элемент списка
	LVITEM lvItem;
	// Маркер завершения операций поиска
	BOOL fContinue = TRUE;
	// Имя файла
	string str = "";
	// Очищаем сисок файлов
	ListView_DeleteAllItems(hFtpListView);
	ListView_SetExtendedListViewStyleEx(hFtpListView, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);
	// Очищаем список структур файлов
	ftpList.clear();
	// Обнуляем поля структуры
	memset(w32FindData, 0, sizeof(WIN32_FIND_DATA));
	// Ищем первый файл в директории
	hInternetFind = FtpFindFirstFile(hIConnect, NULL,
		w32FindData, INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE, 0);
	if(!hInternetFind)
	{
		DWORD dwInetError;
		DWORD dwExtLength = 1000;
		TCHAR szExtErrMsg[1000] = {0};
		TCHAR szErr[1200] = {0};

		// Получаем код ошибки
		if(InternetGetLastResponseInfo( &dwInetError, szExtErrMsg, &dwExtLength ))
			// Выводим сведения ошибки
			MessageBox(0, szExtErrMsg, "Ошибка получения списка каталогов.", MB_OK | MB_ICONEXCLAMATION);
		return ERROR_FTP_COMMAND_LIST;
	}
	// Создаем список изображений (храним иконки к файлам)
	imageList = ImageList_Create(
		GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_MASK | ILC_COLOR32, 1, 1);
	// Цикл поиска файлов в текущей директории фтп сервера
	do 
	{
		// Получаем имя файла и если оно в UTF-8 формате - преобразуем в читабельный вид
		str = w32FindData->cFileName;
		if(str != "." && str.size() > 0)
		{		
			// Добавляем инфо структуру файла в список структур
			ftpList.push_back(*w32FindData);
			// Количество элементов увеличилось
			itemsCount++;
		}
		// Переходим к следующему файлу
		memset(w32FindData, 0, sizeof(WIN32_FIND_DATA));		
		// Пока есть файлы -ищем дальше
		fContinue = InternetFindNextFile(hInternetFind, w32FindData);
	// Пока есть файлы
	} while(fContinue);
	// Сортируем содержимое
	FilesSort(ftpList);
	// Заполняем список
	for(size_t i = 0; i < ftpList.size(); i++)
	{
		// Получаем строку
		str = ftpList.at(i).cFileName;
		// Обнуляем
		memset(&lvItem, 0, sizeof(LVITEM));
		// Заполняем поля информацией
		lvItem.mask = LVIF_IMAGE|LVIF_TEXT;
		lvItem.state = 0;
		lvItem.stateMask = 0 ;
		lvItem.iItem = i;
		lvItem.iImage = i;
		lvItem.iSubItem = 0;
		lvItem.pszText = (LPSTR)str.c_str();
		lvItem.cchTextMax = str.size();
		// Добавляем в список
		ListView_InsertItem(hFtpListView, &lvItem);
		if(strcmp(ftpList.at(i).cFileName, "..") != 0)
		{
			lvItem.iSubItem = 1;
			SYSTEMTIME sysTime;
			memset(&sysTime, 0, sizeof(SYSTEMTIME));
			FileTimeToSystemTime(&ftpList.at(i).ftCreationTime, &sysTime);
			stringstream strStream;
			strStream << sysTime.wDay << "." << sysTime.wMonth << "." << sysTime.wYear;
			string temp = strStream.str();
			lvItem.pszText = (LPSTR)temp.c_str();
			lvItem.cchTextMax = temp.size();
			ListView_SetItem(hFtpListView, &lvItem);

			strStream.str().resize(0);
			strStream.str().clear();
			strStream.str("");
				
			lvItem.iSubItem = 2;
			long size = 0;
			size = ftpList.at(i).nFileSizeHigh + ftpList.at(i).nFileSizeLow;
			if (size == 0)
				strStream << "";
			else if (size < 1024)
				strStream << size << " B";
			else if (size< 1024 * 1024)
				strStream << 1.0 * size / 1024 << " Kb";
			else
				strStream << 1.0 * size / 1024 / 1024 << " Mb";
			temp = strStream.str();
			lvItem.pszText = (LPSTR)temp.c_str();
			lvItem.cchTextMax = temp.size();
			ListView_SetItem(hFtpListView, &lvItem);
		}			
		// Обнуляем поля
		ZeroMemory(&sfi, sizeof(SHFILEINFO));
		// Получаем информацию о переданном элементе
		SHGetFileInfo(ftpList.at(i).cFileName, ftpList.at(i).dwFileAttributes, &sfi, sizeof(SHFILEINFO), 
			SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES | SHGFI_EXETYPE);		
		// Добавляем иконку в список иконок
		ImageList_AddIcon(imageList, sfi.hIcon);
	}
	// Сбор данных о элементах директории закончен
	// Добавляем иконки к списку элементов
	ListView_SetImageList(hFtpListView, imageList, LVSIL_SMALL);
	// Закрываем перечеслитель файлов
	InternetCloseHandle(hInternetFind);
	delete w32FindData;
	// Строка - путь текущей директории
	DWORD dwSize = MAX_PATH;
	TCHAR szDirName[MAX_PATH];
	// Очищаем строку
	str.clear();
	// Получаем путь
	if(!FtpGetCurrentDirectory(hIConnect, szDirName, &dwSize))
		return GetLastError();
	// Преобразовуем путь в читабельный вид
	str = szDirName;	
	// Выводим в статусбар текущий путь
	SendMessage((HWND) hStatusBar, (UINT) SB_SETTEXT, (WPARAM)(INT) 0 | 0, (LPARAM) str.c_str());
	// Все прошло без ошибок
	return 0;
}
// Скачать 
DWORD FtpClient::GetFile(LPCSTR ftpPath, LPCSTR localPath, HWND hProgBar, HWND hStatic)
{
	DWORD dwInetError;
	DWORD dwExtLength = 1000;
	TCHAR *szExtErrMsg = NULL;
	TCHAR errmsg[1000];
	TCHAR szErr[MAX_PATH] = {0};
	szExtErrMsg = errmsg;
	
	DWORD dwRead = 0;
	LONGLONG fileSize = 0;
	BYTE readBuffer[1024] = {0};
	TCHAR szMsgBuff[MAX_PATH] = {0};
	// Получаем доступ к файлу
	HINTERNET hFtpFile = FtpOpenFile(hIConnect, ftpPath, GENERIC_READ, FTP_TRANSFER_TYPE_BINARY | INTERNET_FLAG_RELOAD, 0);
	// Если сервер вернул открытое соединение
	if(hFtpFile)
	{
		// Получаем размер файла
		fileSize = FtpGetFileSize(hFtpFile, 0);
		sprintf(szMsgBuff, "Копирование из %s в %s", ftpPath, localPath);
		SetWindowText(hStatic, szMsgBuff);
		// Расчитываем один процент
		LONGLONG onePercent = fileSize / 100;
		// Задаем параметры прогресбара
		SendMessage(hProgBar, PBM_SETPOS, (WPARAM)0, 0);
		SendMessage(hProgBar, PBM_SETRANGE, 0, (LPARAM)MAKELONG(0, 100));
		SendMessage(hProgBar, PBM_SETSTEP, (WPARAM)1, 0);
		// Создаем локальный файл
		HANDLE localfile = CreateFile(localPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
		// Если файл не создался
		if(localfile == INVALID_HANDLE_VALUE)
		{
			InternetCloseHandle(hFtpFile);
			return ERROR_LOCAL_CREATE_FILE;
		}
		DWORD dwBytesWritten = 0;
		LONGLONG dwReaded = 0;
		// Читаем файл блоками по 1024 байт
		while (InternetReadFile(hFtpFile, readBuffer, 1024, &dwRead) && dwRead)
		{
			// Записываем считанный блок в файл
			WriteFile(localfile, (LPCVOID)readBuffer, dwRead, &dwBytesWritten, 0);
			// Суммируем количество считанных байтов
			dwReaded += dwRead;
			// Если величина скачанных байт достигла одного процента
			if(dwReaded >= onePercent)
			{
				// Обнуляем счетчик считанных байт
				dwReaded = 0;
				// Обновляем прогрессбар
				SendMessage(hProgBar, PBM_STEPIT, 0, 0);
			}
		}
		// Дорисовываем прогресбар до конца
		SendMessage(hProgBar, PBM_SETPOS, 100, 0);
		// Обновляем содержимое прогрессбара
		UpdateWindow(hProgBar);
		// Закрываем файловый хендл
		CloseHandle(localfile);
	}
	else
	{
		// Получаем код ошибки
		InternetGetLastResponseInfo( &dwInetError, szExtErrMsg, &dwExtLength );
		// Копируем в буфер
		sprintf(szErr, "%s", szExtErrMsg);
		// Выводим сведения ошибки
		MessageBox(0, szErr, "Расширенная ошибка.", MB_OK | MB_ICONEXCLAMATION);
		return 0;
	}
	// Закрываем хендл соединения
	InternetCloseHandle(hFtpFile);
	return 0;
}
// Закачать на сервер
DWORD FtpClient::FtpUpload(LPCSTR pathTo, LPCSTR pathFrom, WIN32_FIND_DATA file, HWND hProgBar, HWND hStatic)
{
	// Если задан маркер отмены работы функции
	if(Abort)
	{
		SetEvent(TransitEvent);
		// Выходим
		return 0;
	}

	DWORD dwInetError;
	DWORD dwExtLength = 1000;
	TCHAR *szExtErrMsg = NULL;
	TCHAR errmsg[1000];
	szExtErrMsg = errmsg;
	TCHAR szErr[MAX_PATH] = {0};

	TCHAR szPath[MAX_PATH] = {0};
	TCHAR szPathFrom[MAX_PATH] = {0};
	TCHAR szPathTo[MAX_PATH] = {0};
	vector<WIN32_FIND_DATA> cur;
	// Если директория
	if(file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
		// Формируем серверный путь
		strcat(szPathFrom, pathFrom);
		strcat(szPathFrom, file.cFileName);
		strcat(szPathFrom, "\\");
		// Формируем локальный путь
		strcat(szPathTo, pathTo);
		strcat(szPathTo, file.cFileName);
		
		
		// Создаем папку
		if(!FtpCreateDirectory(hIConnect, szPathTo))
		{
			// Получаем код ошибки
			InternetGetLastResponseInfo( &dwInetError, szExtErrMsg, &dwExtLength );
			// Копируем в буфер
			sprintf(szErr, "%s", szExtErrMsg);
			// Выводим сведения ошибки
			MessageBox(0, szErr, "Ошибка создания каталога на удаленном сервере.", MB_OK | MB_ICONEXCLAMATION);
			Abort = true;
			SetEvent(TransitEvent);
			return 0;
		}
		strcat(szPathTo, "/");
		// Перечисление файлов
		WIN32_FIND_DATA w32FindData;
		HINTERNET hFileFind = 0;
		string str;
		TCHAR f[MAX_PATH] = {0};
		strcat(f, szPathFrom);
		strcat(f, "*.*");
		// Обнуляем поля структуры
		memset(&w32FindData, 0, sizeof(WIN32_FIND_DATA));
		// Ищем первый файл в директории
		hFileFind = FindFirstFile(f, &w32FindData);
		// Цикл поиска файлов в текущей директории фтп сервера
		do 
		{
			// Получаем имя файла и если оно в UTF-8 формате - преобразуем в читабельный вид
			str = w32FindData.cFileName;
			if(str != "." && str != ".." && !(w32FindData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) && str.size())
				// Собираем вектор содержимого текущего каталога
				cur.push_back(w32FindData);
			// Переходим к следующему файлу
			memset(&w32FindData, 0, sizeof(WIN32_FIND_DATA));		
		// Пока есть файлы
		} while(FindNextFile(hFileFind, &w32FindData));
		// Закрываем перечислитель
		FindClose(hFileFind);
		// Запускаем процедуру скачивания для каждого элемента в списке
		for(size_t i = 0; i < cur.size(); i++)
			FtpUpload(szPathTo, szPathFrom, cur.at(i), hProgBar, hStatic);
	}
	// Если файл
	else
	{
		TCHAR path[MAX_PATH] = {0};
		DWORD dwRead = 0;
		LONGLONG fileSize = 0;
		BYTE * readBuffer[1024] = {0};
		// Формируем пути
		memset(szPathFrom, 0, sizeof(TCHAR) * MAX_PATH);
		strcat(szPathFrom, pathFrom);
		strcat(szPathFrom, file.cFileName);

		memset(szPathTo, 0, sizeof(TCHAR) * MAX_PATH);
		strcat(szPathTo, pathTo);
		strcat(szPathTo, file.cFileName);

		// Хендл соединения который должен вернуть сервер в случае успешного выполнения команды STOR
		HINTERNET hFtpFile = 0;
		// Отсылаем серверу команду для размещения
		hFtpFile = FtpOpenFile(hIConnect, szPathTo, GENERIC_WRITE, FTP_TRANSFER_TYPE_BINARY, 0);
		//if(!FtpCommand(hIConnect, TRUE, FTP_TRANSFER_TYPE_BINARY, msg.c_str(), 0, &hFtpFile))
		if(!hFtpFile)
		{
			// Получаем код ошибки
			InternetGetLastResponseInfo( &dwInetError, szExtErrMsg, &dwExtLength );
			// Копируем в буфер
			sprintf(szErr, "%s", szExtErrMsg);
			// Выводим сведения ошибки
			MessageBox(0, szErr, "Ошибка загрузки на сервер.", MB_OK | MB_ICONEXCLAMATION);
			// Отменяем команду размещения на сервере
			if(!FtpCommand(hIConnect, FALSE, FTP_TRANSFER_TYPE_BINARY, "ABOR", 0, 0))
				MessageBox(0, "ABOR не выполнено.", "Ошибка отмены последней операции.", MB_OK | MB_ICONEXCLAMATION);
			// Закрываем соединение открытое для отправки файла
			InternetCloseHandle(hFtpFile);
			Abort = true;
			SetEvent(TransitEvent);
			return 0;
		}
		// Выводим имя файла в качестве текущего обрабатываемого
		SetWindowText(hStatic, file.cFileName);
		// Создаем локальный файл
		HANDLE localfile = CreateFile(szPathFrom, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
		// Проверяем открыт ли локальный файл
		if(localfile == INVALID_HANDLE_VALUE)
		{
			MessageBox(0, "Ошибка открытия локального файла.", "Ошибка.", MB_OK | MB_ICONEXCLAMATION);
			// Закрываем соединение открытое для отправки файла
			InternetCloseHandle(hFtpFile);
			Abort = true;
			SetEvent(TransitEvent);
			// Возвращаем код ошибки
			return ERROR_INVALID_HANDLE;
		}
		// Получаем размер файла
		LARGE_INTEGER sz;
		sz.HighPart = file.nFileSizeHigh;
		sz.LowPart = file.nFileSizeLow;
		fileSize = sz.QuadPart;
		// Расчитываем один процент
		LONGLONG onePercent = fileSize / 100;
		// Задаем параметры прогресбара
		SendMessage(hProgBar, PBM_SETPOS, (WPARAM)0, 0);
		SendMessage(hProgBar, PBM_SETRANGE, 0, (LPARAM)MAKELONG(0, 100));
		SendMessage(hProgBar, PBM_SETSTEP, (WPARAM)1, 0);

		DWORD dwBytesWritten = -1;
		DWORD dwReaded = -1;
		dwRead = -1;
		// Читаем файл блоками по 1024 байт
		while (dwBytesWritten && dwRead)
		{
			// Читаем блок
			ReadFile(localfile, (LPVOID)readBuffer, 1024, &dwRead, 0);
			// Записываем считанный блок
			InternetWriteFile(hFtpFile, readBuffer, dwRead, &dwBytesWritten);
			// Суммируем количество считанных байтов
			dwReaded += dwRead;
			// Если величина скачанных байт достигла одного процента
			if(dwReaded >= onePercent)
			{
				// Обнуляем счетчик считанных байт
				dwReaded = 0;
				// Обновляем прогрессбар
				SendMessage(hProgBar, PBM_STEPIT, 0, 0);
			}
			// Если задан маркер отмены работы функции
			if(Abort)
			{
				// Закрываем хендлы
				CloseHandle(localfile);
				InternetCloseHandle(hFtpFile);
				SetEvent(TransitEvent);
				// Выходим
				return 0;
			}
		}
		// Дорисовываем прогресбар до конца
		SendMessage(hProgBar, PBM_SETPOS, 100, 0);
		// Обновляем содержимое прогрессбара
		UpdateWindow(hProgBar);
		// Закрываем файловый хендл
		CloseHandle(localfile);
		// Закрываем хендл соединения
		InternetCloseHandle(hFtpFile);
	}
	return 0;
}

// Преобразовать из UTF8 в CP1251
//string FtpClient::Utf8_to_cp1251(const char *str)
//{
//	string res;	
//	int result_u, result_c;
//
//
//	result_u = MultiByteToWideChar(CP_UTF8,
//		0,
//		str,
//		-1,
//		0,
//		0);
//	
//	if (!result_u)
//		return 0;
//
//	wchar_t *ures = new wchar_t[result_u];
//
//	if(!MultiByteToWideChar(CP_UTF8,
//		0,
//		str,
//		-1,
//		ures,
//		result_u))
//	{
//		delete[] ures;
//		return 0;
//	}
//
//
//	result_c = WideCharToMultiByte(
//		1251,
//		0,
//		ures,
//		-1,
//		0,
//		0,
//		0, 0);
//
//	if(!result_c)
//	{
//		delete [] ures;
//		return 0;
//	}
//
//	char *cres = new char[result_c];
//
//	if(!WideCharToMultiByte(
//		1251,
//		0,
//		ures,
//		-1,
//		cres,
//		result_c,
//		0, 0))
//	{
//		delete[] cres;
//		return 0;
//	}
//	delete[] ures;
//	res.append(cres);
//	delete[] cres;
//	return res;
//}
//// Преобразовать из CP1251 в UTF8
//string FtpClient::cp1251_to_utf8(const char *str)
//{
//	string res;	
//	int result_u, result_c;
//
//
//	result_u = MultiByteToWideChar(1251,
//		0,
//		str,
//		-1,
//		0,
//		0);
//	
//	if (!result_u)
//		return 0;
//
//	wchar_t *ures = new wchar_t[result_u];
//
//	if(!MultiByteToWideChar(1251,
//		0,
//		str,
//		-1,
//		ures,
//		result_u))
//	{
//		delete[] ures;
//		return 0;
//	}
//
//
//	result_c = WideCharToMultiByte(
//		CP_UTF8,
//		0,
//		ures,
//		-1,
//		0,
//		0,
//		0, 0);
//
//	if(!result_c)
//	{
//		delete [] ures;
//		return 0;
//	}
//
//	char *cres = new char[result_c];
//
//	if(!WideCharToMultiByte(
//		CP_UTF8,
//		0,
//		ures,
//		-1,
//		cres,
//		result_c,
//		0, 0))
//	{
//		delete[] cres;
//		return 0;
//	}
//	delete[] ures;
//	res.append(cres);
//	delete[] cres;
//	return res;
//}
// Сортировка файлов